<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Circle Tiling</title>
    <script type="text/javascript" src="./vec2.js"></script>
    <script type="text/javascript">
        let EPS = 1e-8;
        let sqr = (x) => {
            return x*x;
        };
        let sqrt = (x) => {
            return Math.sqrt(x);
        }

        class Circle {
            constructor(p, r) {
                this.p = p;
                this.r = r;
            }
            inverse(pos) {
                let ip = this.p.sub(pos);
                return new Circle(
                    pos.add(ip.div(ip.len2() - sqr(this.r))),
                    this.r/(ip.len2() - sqr(this.r))
                );
            }
            segment(d0, d1) {
                return new Segment(
                    this.p.add(d0.mul(this.r)), 
                    this.p.add(d1.mul(this.r)),
                    1/this.r
                );
            }
        }

        class Segment {
            constructor(v0, v1, s) {
                this.vs = [v0, v1];
                this.s = s;
            }
            draw(cnt) {
                if (Math.abs(this.s) < EPS) {
                    cnt.lineTo(this.vs[1].x, this.vs[1].y);
                } else {
                    let a = this.vs[0];
                    let b = this.vs[1];
                    let c = a.add(b).div(2);
                    let d = b.sub(a).rr();
                    let l = d.len()/2;
                    d = d.div(2*l);
                    let s = this.s;
                    let t = sqrt(1/(s*s) - l*l);
                    let p = c.add(d.mul(t));

                    let da = a.sub(p);
                    let aa = Math.atan2(da.y, da.x);
                    let db = b.sub(p);
                    let ab = Math.atan2(db.y, db.x);

                    cnt.arc(p.x, p.y, 1/s, aa, ab);
                }
            }
            uniform(pos) {
                let p0 = this.vs[0].sub(pos);
                let p1 = this.vs[1].sub(pos);
                let z = p1.sub(p0);
                let b = z.len()/2;
                let c = p0.add(p1).div(2);
                let d = z.rr().norm();
                let s = this.s;
                let t = sqrt(1-s*s*b*b);
                let u = c.mul(s).add(d.mul(t));
                let f = u.norm();
                let m = s*p0.dot(p1) + 2*c.dot(d)*t;
                let l = m/(sqrt(s*m + 1) + 1);
                return new Uniform(f, l, s);
            }
        }

        class Uniform {
            constructor(d, l, s) {
                this.d = d;
                this.l = l;
                this.s = s;
            }
            draw(cnt, pos) {
                if (Math.abs(this.s) < sqrt(EPS)) {
                    let c = pos.add(this.d.mul(this.l));
                    let f = c.add(this.d.lr().mul(1e4));
                    let t = c.add(this.d.rr().mul(1e4));
                    cnt.moveTo(f.x, f.y);
                    cnt.lineTo(t.x, t.y);
                } else {
                    let r = this.s > 0 ? 1/this.s : -1/this.s;
                    let p = pos.add(this.d.mul(this.l + 1/this.s));
                    cnt.arc(p.x, p.y, r, 0, 2*Math.PI);
                }
            }
            inverse() {
                let d_ = this.d;
                let l_ = this.s/(this.l*this.s + 2);
                let s_ = this.l*(this.s*this.l + 2);
                return new Uniform(d_, l_, s_);
            }
        }

        class Triangle {
            constructor(vertices, sigmas) {
                this.vertices = vertices;
                this.sigmas = sigmas;
            }
            seg(i) {
                return new Segment(
                    this.vertices[i%3],
                    this.vertices[(i+1)%3],
                    this.sigmas[i%3]
                );
            }
            draw(cnt) {
                cnt.fillStyle = "rgb(127,127,127)";
                cnt.beginPath();
                for (let i = 0; i < 3; ++i) {
                    this.seg(i).draw(cnt);
                }
                cnt.closePath();
                cnt.fill();
            }
            draw_uni(cnt, pos) {
                for (let i = 0; i < 3; ++i) {
                    cnt.strokeStyle = "rgb(0,0,0)";
                    cnt.beginPath();
                    this.seg(i).uniform(pos).draw(cnt, pos);
                    cnt.stroke();
                }
            }
            draw_inv(cnt, pos) {
                for (let i = 0; i < 3; ++i) {
                    cnt.strokeStyle = "rgb(0,0,0)";
                    cnt.beginPath();
                    this.seg(i).uniform(pos).inverse().draw(cnt, pos);
                    cnt.stroke();
                }
            }
            incircle() {
                let pos = this.vertices[0];

                let ur = this.seg(0).uniform(pos).inverse();
                let uo = this.seg(1).uniform(pos).inverse();
                let ul = this.seg(2).uniform(pos).inverse();


                let dr = ur.d.lr();
                let dl = ul.d.rr();
                let d = dr.add(dl).norm();
                let pr = pos.add(ur.d.mul(ur.l));
                let pl = pos.add(ul.d.mul(ul.l));
                let prl = pr.add(d.lr().mul(pl.sub(pr).cross(dl)/d.lr().cross(dl)));
                let pc = pr.add(prl).div(2);

                let s = uo.s;
                let sk = pc.sub(pos).sub(uo.d.mul(uo.l)).mul(s).sub(uo.d);

                let td = sqrt(sqr(sk.dot(d)) - sk.len2() + 1) + sk.dot(d);
                let pp = pc.sub(pos);
                let pp2 = pp.len2();
                let ppd = pp.dot(uo.d);
                let tn = 2*(ppd - uo.l) - s*(pp2 - 2*ppd*uo.l + sqr(uo.l));
                let t = tn/td;
                let p = pc.add(d.mul(t));
                
                let dc = pos.sub(p).mul(s).add(uo.d.mul(s*uo.l + 1)).norm();
                let cb = -d.dot(dc);
                let ca = d.dot(dr);
                let sa = d.cross(dr);
                let ta = sa/ca;
                let l = pr.sub(prl).len()/2 + t*ta;
                let ax = s*sqr(ca);
                let bx = cb - sa - s*l*ca*sa;
                let cx = -l*ca*(2 + s*l*ca);
                let x = (sqrt(sqr(bx) - ax*cx) - bx)/ax;
                let ic = p.add(d.mul(x));
                let ir = l*ca + x*sa;

                return (new Circle(ic, ir)).inverse(pos);
            }
            draw_inner(cnt) {
                cnt.strokeStyle = "rgb(0,0,0)";

                cnt.beginPath();
                for (let i = 0; i < 3; ++i) {
                    this.seg(i).draw(cnt);
                }
                cnt.stroke();
                
                let ic = this.incircle();
                console.log(ic.p.toString());

                cnt.beginPath();
                cnt.arc(ic.p.x, ic.p.y, ic.r, 0, 2*Math.PI);
                cnt.stroke();
            }
        }

        window.addEventListener("load", () => {
            let cnv = document.getElementById("cnv");
            let cnt = cnv.getContext("2d");
            let triangle = new Triangle(
                [new Vec2(400.0, 100.0), new Vec2(53.0, 700.0), new Vec2(800.0 - 53.0, 700.0)],
                [1e-3, 4e-4, 0]
            );
            triangle.draw_inner(cnt, 1);
        });
    </script>
    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <canvas width=800 height=800 id="cnv">HTML5 Canvas not supported</canvas>
</body>
</html>
