<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Circle Tiling</title>
    <script type="text/javascript" src="./vec2.js"></script>
    <script type="text/javascript">
        let EPS = 1e-8;
        let sqr = (x) => {
            return x*x;
        };
        let sqrt = (x) => {
            return Math.sqrt(x);
        } 

        class Segment {
            constructor(v0, v1, s) {
                this.vs = [v0, v1];
                this.s = s;
            }
            draw(cnt) {
                if (Math.abs(this.s) < EPS) {
                    cnt.lineTo(this.vs[1].x, this.vs[1].y);
                } else {
                    let a = this.vs[0];
                    let b = this.vs[1];
                    let c = a.add(b).div(2);
                    let d = b.sub(a).rr();
                    let l = d.len()/2;
                    d = d.div(2*l);
                    let s = this.s;
                    let t = sqrt(1/(s*s) - l*l);
                    let p = c.add(d.mul(t));

                    let da = a.sub(p);
                    let aa = Math.atan2(da.y, da.x);
                    let db = b.sub(p);
                    let ab = Math.atan2(db.y, db.x);

                    cnt.arc(p.x, p.y, 1/s, aa, ab);
                }
            }
        }

        class Uniform {
            constructor(d, l, s) {
                this.d = d;
                this.l = l;
                this.s = s;
            }
            draw(cnt, pos) {
                if (Math.abs(this.s) < sqrt(EPS)) {
                    let c = pos.add(this.d.mul(this.l));
                    let f = c.add(this.d.lr().mul(1e4));
                    let t = c.add(this.d.rr().mul(1e4));
                    cnt.moveTo(f.x, f.y);
                    cnt.lineTo(t.x, t.y);
                } else {
                    let r = this.s > 0 ? 1/this.s : -1/this.s;
                    let p = pos.add(this.d.mul(this.l + 1/this.s));
                    cnt.arc(p.x, p.y, r, 0, 2*Math.PI);
                }
            }
        }

        class Triangle {
            constructor(vertices, sigmas) {
                this.vertices = vertices;
                this.sigmas = sigmas;
            }
            seg(i) {
                return new Segment(
                    this.vertices[i%3],
                    this.vertices[(i+1)%3],
                    this.sigmas[i%3]
                );
            }
            draw(cnt) {
                cnt.fillStyle = "rgb(127,127,127)";
                cnt.beginPath();
                for (let i = 0; i < 3; ++i) {
                    this.seg(i).draw(cnt);
                }
                cnt.closePath();
                cnt.fill();
            }
            draw_uni(cnt, pos) {
                for (let i = 0; i < 3; ++i) {
                    cnt.strokeStyle = "rgb(0,0,0)";
                    cnt.beginPath();
                    seg_to_uni(this.seg(i), pos).draw(cnt, pos);
                    cnt.stroke();
                }
            }
            draw_inv(cnt, pos, ir) {
                for (let i = 0; i < 3; ++i) {
                    cnt.strokeStyle = "rgb(0,0,0)";
                    cnt.beginPath();
                    inverse(seg_to_uni(this.seg(i), pos), ir).draw(cnt, pos);
                    cnt.stroke();
                }
            }
            draw_inner(cnt, ir) {
                let pos = this.vertices[0];
                cnt.strokeStyle = "rgb(0,0,0)";

                let ur = inverse(seg_to_uni(this.seg(0), pos), ir);
                cnt.beginPath();
                ur.draw(cnt, pos);
                cnt.stroke();
                
                let uo = inverse(seg_to_uni(this.seg(1), pos), ir);
                cnt.beginPath();
                uo.draw(cnt, pos);
                cnt.stroke();
                
                let ul = inverse(seg_to_uni(this.seg(2), pos), ir);
                cnt.beginPath();
                ul.draw(cnt, pos);
                cnt.stroke();

                let dr = ur.d.lr();
                let dl = ul.d.rr();
                let d = dr.add(dl).norm();
                let pr = this.seg(0).vs[1].sub(pos);
                let pl = this.seg(2).vs[0].sub(pos);
                pr = pr.div(pr.len2()).mul(ir*ir).add(pos);
                pl = pl.div(pl.len2()).mul(ir*ir).add(pos);
                let prl = pr.add(d.lr().mul(pl.sub(pr).cross(dl)/d.lr().cross(dl)));
                let pc = pr.add(prl).div(2);

                cnt.strokeStyle = "rgb(255,0,0)";
                
                cnt.beginPath();
                cnt.moveTo(pc.x, pc.y);
                let _dl = pc.add(d.mul(1e4));
                cnt.lineTo(_dl.x, _dl.y);
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(pr.x, pr.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(pl.x, pl.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(prl.x, prl.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(pc.x, pc.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                cnt.moveTo(pr.x, pr.y);
                cnt.lineTo(prl.x, prl.y);
                cnt.stroke();

                cnt.strokeStyle = "rgb(0,0,255)";

                let s = uo.s;
                let sk = pc.sub(pos).sub(uo.d.mul(uo.l)).mul(s).sub(uo.d);

                let _c = pc.sub(sk.div(s));
                cnt.beginPath();
                cnt.arc(_c.x, _c.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                let move = false;
                for (let i = 0; i < 1000; ++i) {
                    let x = i;
                    let y = sqr(x) + 2*sk.div(s).dot(d)*x + sk.div(s).len2() - 1/sqr(s);
                    let z = pc.add(d.mul(x)).add(d.lr().mul(1e-3*y));
                    if (!move) {
                        cnt.moveTo(z.x, z.y);
                        move = true;
                    } else {
                        cnt.lineTo(z.x, z.y);
                    }
                }
                cnt.stroke();

                /*
                let t_ = (sqrt(sqr(sk.dot(d)) - sk.len2() + 1) - sk.dot(d))/s;
                let p_ = pc.add(d.mul(t_));
                cnt.beginPath();
                cnt.arc(p_.x, p_.y, 4, 0, 2*Math.PI);
                cnt.stroke();                
                */

                let td = sqrt(sqr(sk.dot(d)) - sk.len2() + 1) + sk.dot(d);
                let pp = pc.sub(pos);
                let pp2 = pp.len2();
                let ppd = pp.dot(uo.d);
                let tn = 2*(ppd - uo.l) - s*(pp2 - 2*ppd*uo.l + sqr(uo.l));
                //let tn = 2*pc.sub(pos).dot(ul.d)*(ul.l*s + 1) - 2*ul.l - s*pc.sub(pos).len2();
                let t = tn/td;
                let p = pc.add(d.mul(t));
                
                cnt.beginPath();
                cnt.arc(p.x, p.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.strokeStyle = "rgb(0,127,0)";
                
                let dc = pos.sub(p).mul(s).add(uo.d.mul(s*uo.l + 1)).norm();
                let cb = -d.dot(dc);
                let ca = d.dot(dr);
                let sa = d.cross(dr);
                let ta = sa/ca;
                let l = pr.sub(prl).len()/2 + t*ta;
                let ax = s*sqr(ca);
                let bx = cb - sa - s*l*ca*sa;
                let cx = -l*ca*(2 + s*l*ca);
                let x = (sqrt(sqr(bx) - ax*cx) - bx)/ax;
                let ic = p.add(d.mul(x));
                let is = 1/(l*ca + x*sa);

                let _dc = p.add(dc.mul(1/s));
                cnt.beginPath();
                cnt.moveTo(p.x, p.y);
                cnt.lineTo(_dc.x, _dc.y);
                cnt.stroke();

                let _prt = p.add(d.lr().mul(l));
                let _plt = p.add(d.rr().mul(l));
                cnt.beginPath();
                cnt.moveTo(_prt.x, _prt.y);
                cnt.lineTo(_plt.x, _plt.y);
                cnt.stroke();

                let _h = d.lr().dot(p.sub(_c));
                cnt.beginPath();
                move = false;
                for (let i = 0; i < 1000; ++i) {
                    let x = i - 500;
                    let y = sqr(_h) + sqr(sqrt(1/sqr(s) - sqr(_h)) + x) - sqr(1/s + l*ca + x*sa);
                    //let y = 1 - sqr(cb) + sqr(cb + s*x) - sqr(1 + s*l*ca + s*x*sa);
                    //let y = ax*sqr(x) + 2*bx*x + cx;
                    let z = p.add(d.mul(x)).add(d.lr().mul(1e-3*y));
                    if (!move) {
                        cnt.moveTo(z.x, z.y);
                        move = true;
                    } else {
                        cnt.lineTo(z.x, z.y);
                    }
                }
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(ic.x, ic.y, 4, 0, 2*Math.PI);
                cnt.stroke();

                cnt.beginPath();
                cnt.arc(ic.x, ic.y, 1/is, 0, 2*Math.PI);
                cnt.stroke();
            }
        }

        let seg_to_uni = (seg, pos) => {
            let p0 = seg.vs[0].sub(pos);
            let p1 = seg.vs[1].sub(pos);
            let z = p1.sub(p0);
            let b = z.len()/2;
            let c = p0.add(p1).div(2);
            let d = z.rr().norm();
            let s = seg.s;
            let t = sqrt(1-s*s*b*b);
            let u = c.mul(s).add(d.mul(t));
            let f = u.norm();
            let m = s*p0.dot(p1) + 2*c.dot(d)*t;
            let l = m/(sqrt(s*m + 1) + 1);
            return new Uniform(f, l, s);
        }

        let inverse = (uni, ir) => {
            let d_ = uni.d;
            let l_ = uni.s/(uni.l*uni.s + 2)*(ir*ir);
            let s_ = uni.l*(uni.s*uni.l + 2)/(ir*ir);
            return new Uniform(d_, l_, s_);
        };

        window.addEventListener("load", () => {
            let cnv = document.getElementById("cnv");
            let cnt = cnv.getContext("2d");
            let triangle = new Triangle(
                [new Vec2(400.0, 100.0), new Vec2(53.0, 700.0), new Vec2(800.0 - 53.0, 700.0)],
                [0.0, 0.0, 0.0]
            );
            let draw = (pos, ir) => {
                cnt.clearRect(0,0,cnv.width,cnv.height);
                triangle.draw(cnt);
                triangle.draw_uni(cnt, pos);
                triangle.draw_inv(cnt, pos, ir);
            }
            /*
            cnv.addEventListener("mousemove", (e) => {
                let p = new Vec2(e.pageX, e.pageY);
                draw(p, 2e2);
            })
            draw(new Vec2(400, 400), 2e2);
            */
            triangle.draw_inner(cnt, 4e2);
        });
    </script>
    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <canvas width=800 height=800 id="cnv">HTML5 Canvas not supported</canvas>
</body>
</html>
